<html>
	<head>
		<title>Lambertian BRDF Shaders</title>
		<style>
			canvas { width: 100%; height: 100%; }
			body{ margin: 0; }
		</style>
	</head>
	<body>
		<script src="libs\three.min.js"></script>
		<script src="libs\stats.min.js"></script>
		<script src="libs\OrbitControls.js"></script>
		<script src='libs\OBJLoader.js'></script>
		<script src='libs\GLTFLoader.js'></script>
		<script src='libs\dat.gui.min.js'></script>
		<script src='libs\BufferGeometryUtils.js'></script>
		<script src='libs\SceneUtils.js'></script>

		<script type='text/x-glsl' id='vs'>
			attribute vec4 tangent;
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec3 vTangent;
			varying vec3 vBitangent;
			varying vec2 vUv;
			varying vec3 wNormal;
			
			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
				vNormal = normalize(normalMatrix * normal);
				vec3 objectTangent = vec3( tangent.xyz );
				vec3 transformedTangent = normalMatrix * objectTangent;
				vTangent = normalize( transformedTangent );
				vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
				vUv = uv;
				wNormal = (modelViewMatrix * vec4(vNormal, 0.0)).xyz;
				gl_Position = projectionMatrix * vPos;
			}
		</script>

		<script type='text/x-glsl' id='fs'>
			precision highp float;
			precision highp int;

			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec3 vNormal;
			varying vec3 wNormal;
			varying vec2 vUv;
			
			//per modello gltf
			varying vec3 vTangent;
			varying vec3 vBitangent;

			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;
			//uniform vec3 pointLightPosition4;

			uniform vec3 clight;
			uniform samplerCube envMap;

			//uniform 
			vec3 cdiff;
			uniform sampler2D diffuseMap;

			uniform vec3 cspec;
			//uniform sampler2D specularMap;

			uniform float roughness;
			//uniform sampler2D roughnessMap;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			uniform samplerCube irradianceMap;
			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			#define saturate(a) clamp( a, 0.0, 1.0 )

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
				float k = roughness*roughness;
				return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;
			}

			void main() {

				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );
				//vec4 lPosition4 = viewMatrix * vec4( pointLightPosition4, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);
				//vec3 l4 = normalize(lPosition4.xyz - vPosition.xyz);

				//GLTF MODEL
				/*
				vec3 normal = normalize(vNormal);
				vec3 tangent = normalize(vTangent);
				vec3 bitangent = normalize(vBitangent);
				mat3 vTBN = mat3(tangent, bitangent, normal);
				vec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;
				mapN.xy = normalScale * mapN.xy;
				vec3 n = normalize(vTBN*mapN);
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
				*/

				//OBJ MODEL
				//TOM AKE NORMAL MAP WORK perturbNormal2Arb(...)
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition, n);
				vec3 r = inverseTransformDirection(vReflect, viewMatrix);

				vec3 h = normalize( v + l);
				vec3 h2 = normalize( v + l2);
				vec3 h3 = normalize( v + l3);
				//vec3 h4 = normalize( v + l4);

				float nDotl = max(dot( n, l ),0.000001);
				float nDotl2 = max(dot( n, l2 ),0.000001);
				float nDotl3 = max(dot( n, l3 ),0.000001);
				//float nDotl4 = max(dot( n, l4 ),0.000001);

				float lDoth = max(dot( l, h ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);
				//float lDoth4 = max(dot( l4, h4 ),0.000001);

				float nDoth = max(dot( n, h ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);
				//float nDoth4 = max(dot( n, h4 ),0.000001);

				float vDoth = max(dot( v, h ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);
				//float vDoth4 = max(dot( v, h4 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				//WITH TEXTURES INSTEAD OF VALUES
				//DIFFUSION
				cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
				cdiff = pow( cdiff, vec3(2.2));
				//SPECULAR
				//cspec = texture2D(specularMap, vUv*textureRepeat).rgb;
				//cspec = pow(cspec, vec3(2.2));
				//ROUGHNESS
				//roughness = texture2D(roughnessMap, vUv*textureRepeat).r;

				vec3 fresnel = FSchlick( nDotv );

				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);
				vec3 BRDF2 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);
				vec3 BRDF3 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);
				//vec3 BRDF4 = (vec3(1.0)-fresnel4)*cdiff/PI + fresnel4*GSmith(nDotv,nDotl4)*DGGX(nDoth4,roughness*roughness)/(4.0*nDotl4*nDotv);

				//SPECULAR + ROUGHNESS
				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8 );
				vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
				//SPECULAR
				//vec3 envLight = textureCube(envMap, vec3(-r.x, r.yz)).rgb;

				//REFRACTIVE SHADER
				vec3 I = wPosition.xyz - cameraPosition;
				vec3 refractedDirection = refract(I, wNormal, 0.4);
				//vec3 envLight = textureCubeLodEXT(envMap, vec3( -refractedDirection.x, refractedDirection.yz ), specularMIPLevel).rgb;
				
				//linearize from sRGB
				//envLight = pow( envLight, vec3(2.2));

				//SPECULAR + ROUGHNESS
				//CON LUCE AMBIENTALE
				vec3 outRadiance = envLight*fresnel*BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
				//CON LUCE ILLUMINAZIONE
				//vec3 outRadiance = envLight*fresnel*((BRDF2*nDotl2)+(BRDF3*nDotl3));

				//SPECULAR
				//CON RIFRAZIONE
				//vec3 outRadiance = envLight*fresnel;

				//MATERIAL
				//vec3 outRadiance = PI * clight * ((nDotl*BRDF)+(nDotl2*BRDF2)+(nDotl3*BRDF3));

				outRadiance *= cdiff;

				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);

				
			}
		</script>

		<script type='text/x-glsl' id='fs_wood'>
			precision highp float;
			precision highp int;

			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec3 vNormal;
			varying vec3 wNormal;
			varying vec2 vUv;

			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;

			uniform vec3 clight;
			uniform samplerCube envMap;

			vec3 cdiff;
			uniform sampler2D diffuseMap;
			
			vec3 cspec;
			uniform sampler2D specularMap;

			float roughness;
			uniform sampler2D roughnessMap;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			uniform samplerCube irradianceMap;

			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			#define saturate(a) clamp( a, 0.0, 1.0 )

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
				float k = roughness*roughness;
				return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;
			}

			void main() {

				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);

				//OBJ MODEL
				//TO MAKE NORMAL MAP WORK perturbNormal2Arb(...)
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition, n);
				vec3 r = inverseTransformDirection(vReflect, viewMatrix);

				vec3 h = normalize( v + l);
				vec3 h2 = normalize( v + l2);
				vec3 h3 = normalize( v + l3);

				float nDotl = max(dot( n, l ),0.000001);
				float nDotl2 = max(dot( n, l2 ),0.000001);
				float nDotl3 = max(dot( n, l3 ),0.000001);

				float lDoth = max(dot( l, h ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);

				float nDoth = max(dot( n, h ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);

				float vDoth = max(dot( v, h ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				//WITH TEXTURES INSTEAD OF VALUES
				//DIFFUSION
				cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
				cdiff = pow( cdiff, vec3(2.2));
				//SPECULAR
				cspec = texture2D(specularMap, vUv*textureRepeat).rgb;
				cspec = pow(cspec, vec3(2.2));
				//ROUGHNESS
				roughness = texture2D(roughnessMap, vUv*textureRepeat).r;

				vec3 fresnel = FSchlick( nDotv );

				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8 );
				vec3 envLight = textureCubeLodEXT(envMap, vec3( -r.x, r.yz ), specularMIPLevel).rgb;
				
				vec3 irradiance = textureCube(irradianceMap, wNormal).rgb;
				irradiance = pow(irradiance, vec3(2.2));

				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);
				vec3 BRDF2 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);
				vec3 BRDF3 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);

				vec3 sBRDF = BRDF_Specular_GGX_Environment(n, v, cspec, roughness);

				//MATERIAL
				//vec3 outRadiance = clight*PI * nDotl*(sBRDF);
				//vec3 outRadiance = clight*PI*BRDF*nDotl + envLight*fresnel*sBRDF;
				vec3 outRadiance = BRDF*nDotl*clight*PI + irradiance*cdiff;

				//outRadiance *= cdiff;

				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);

				
			}
		</script>

		<script type='text/x-glsl' id='fs_refraction'>
			precision highp float; 
			precision highp int;

			varying vec3 vPosition;
			varying vec3 wPosition;

			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;

			varying vec3 vNormal;
			varying vec3 wNormal;
			varying vec2 vUv;

			uniform vec3 clight;
			uniform samplerCube envMap;

			vec3 cdiff;
			uniform vec3 cspec;
			uniform float roughness;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			uniform float mBias;
			uniform float mPower;
			uniform float mScale;
			float vReflectionFactor;

			const float PI = 3.14159;

			#define saturate(a) clamp( a, 0.0, 1.0 )

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
				float k = roughness*roughness;
				return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);

				//OBJ MODEL
				//TO MAKE NORMAL MAP WORK perturbNormal2Arb(...)
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition, n);
				vec3 r = inverseTransformDirection(vReflect, viewMatrix);

				vec3 h = normalize( v + l);
				vec3 h2 = normalize( v + l2);
				vec3 h3 = normalize( v + l3);

				float nDotl = max(dot( n, l ),0.000001);
				float nDotl2 = max(dot( n, l2 ),0.000001);
				float nDotl3 = max(dot( n, l3 ),0.000001);

				float lDoth = max(dot( l, h ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);

				float nDoth = max(dot( n, h ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);

				float vDoth = max(dot( v, h ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				vec3 fresnel = FSchlick( nDotv );

				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);
				vec3 BRDF2 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);
				vec3 BRDF3 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);

				vec3 sBRDF = BRDF_Specular_GGX_Environment(n, v, cspec, roughness);

				//SPECULAR + ROUGHNESS
				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8 );

				//REFRACTIVE SHADER with opacity
				vec3 I = wPosition.xyz - cameraPosition;
				vec3 refractedDirection = refract(I, wNormal, 0.4);
				//vec3 envLight = textureCube(envMap, vec3( -refractedDirection.x, refractedDirection.yz ), specularMIPLevel).rgb;
				vec3 specLight = textureCubeLodEXT(envMap, vec3( -refractedDirection.x, refractedDirection.yz ), specularMIPLevel).rgb;
				vec3 envLight = textureCubeLodEXT(envMap, vec3( -r.x, r.yz ), specularMIPLevel).rgb;

				//linearize from sRGB
				specLight = pow( specLight, vec3(2.2));
				envLight = pow( envLight, vec3(2.2));

				vReflectionFactor = mBias + mScale * pow( 1.0 + dot( normalize( I ), wNormal ), mPower );

				//vec3 outRadiance = envLight*fresnel * (sBRDF + nDotl*BRDF);
				vec3 outRadiance = mix( envLight, specLight, clamp(vReflectionFactor, 0.0, 1.0)) * (sBRDF+BRDF);
				//envLight*fresnel +sBRDF*BRDF;
				//ADD COLOR
				//outRadiance *= cdiff;

				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>

		<script type='text/x-glsl' id='fs_gold' >
			precision highp float; 
			precision highp int;

			varying vec3 vPosition;
			varying vec3 wPosition;

			varying vec3 vNormal;
			varying vec3 wNormal;
			varying vec2 vUv;

			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;

			uniform vec3 clight;
			uniform samplerCube envMap;

			uniform vec3 cdiff;
			uniform vec3 cspec;
			uniform float roughness;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			const float PI = 3.14159;

			#define saturate(a) clamp( a, 0.0, 1.0 )

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
				float k = roughness*roughness;
				return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);

				//OBJ MODEL
				//TO MAKE NORMAL MAP WORK perturbNormal2Arb(...)
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition, n);
				vec3 r = inverseTransformDirection(vReflect, viewMatrix);

				vec3 h = normalize( v + l);
				vec3 h2 = normalize( v + l2);
				vec3 h3 = normalize( v + l3);

				float nDotl = max(dot( n, l ),0.000001);
				float nDotl2 = max(dot( n, l2 ),0.000001);
				float nDotl3 = max(dot( n, l3 ),0.000001);

				float lDoth = max(dot( l, h ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);

				float nDoth = max(dot( n, h ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);

				float vDoth = max(dot( v, h ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				vec3 fresnel = FSchlick( nDotv );

				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);
				vec3 BRDF2 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);
				vec3 BRDF3 = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);

				vec3 sBRDF = BRDF_Specular_GGX_Environment(n, v, cspec, roughness);

				//SPECULAR + ROUGHNESS
				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8 );
				vec3 envLight = textureCubeLodEXT(envMap, vec3( -r.x, r.yz ), specularMIPLevel).rgb;

				//linearize from sRGB
				envLight = pow( envLight, vec3(2.2));

				vec3 outRadiance = envLight*sBRDF + clight*PI*BRDF*nDotl;
				//ADD COLOR
				outRadiance *= cdiff;

				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>

		<script>
			var scene, camera, renderer, stats, controls, gui;
			var lightMesh, lightMesh2, lightMesh3;
			var textureCube, cubescene, geom;
			var objects = new Array();
			var shaderMaterial, mesh;
			var shaderMaterialChair;
			var material = 'fs_wood';
			var selection = '';

			var loadedModel = false;

			var lightParameters = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
				intensity: 1.0,
			};

			var cdiff = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
			};

			var cdiffmetal = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
			}

			var cdiffglass = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
			};

			var cspec = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
				roughness: 0.5
			};

			var cspecmetal = {
				red: 1.0,
				green: 0.78,
				blue: 0.34,
				roughness: 0.2
			};

			var cspecglass = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
				roughness: 0.5
			};

			var normalMap = textureLoader('textures/dresser/normal.png');
			var diffuseMap = textureLoader('textures/dresser/diffuse.png');
			var roughnessMap = textureLoader('textures/dresser/roughness.png');
			var specularMap = textureLoader('textures/dresser/specular.png');

			var normalMapChair = textureLoader('textures/bigchair/Lnormal.png');
			var diffuseMapChair = textureLoader('textures/bigchair/Lchair.jpg');
			var roughnessMapChair = textureLoader('textures/bigchair/Lrough.jpg');
			var specularMapChair = textureLoader('textures/bigchair/Lspec.jpg');

			var normalMapLegs = textureLoader('textures/bigchair/Wnormal.png');
			var diffuseMapLegs = textureLoader('textures/bigchair/Wchair.jpg');
			var specularMapLegs = textureLoader('textures/bigchair/Wspec.png');
			var roughnessMapLegs = textureLoader('textures/bigchair/Wrough.png');

			var loader = new THREE.CubeTextureLoader();
			loader.setPath( 'textures/lounge/' );

			var textureCube = loader.load( [
				/*'totality_bk.png', 'totality_ft.png', 
				'totality_dn.png', 'totality_up.png', 
				'totality_lf.png', 'totality_rt.png',*/

				/*'posx.png', 'negx.png',
				'posy.png', 'negy.png',
				'posz.png', 'negz.png'*/

				'px.png', 'nx.png',
				'py.png', 'ny.png',
				'pz.png', 'nz.png'
			] );
			textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			var imgl = new THREE.TextureLoader();

			var path = 'textures/lounge/'
			var textureEnvironment = [
				new THREE.MeshBasicMaterial({map: imgl.load(path+'px.png'), side: THREE.BackSide}),
				new THREE.MeshBasicMaterial({map: imgl.load(path+'nx.png'), side: THREE.BackSide}),
				new THREE.MeshBasicMaterial({map: imgl.load(path+'py.png'), side: THREE.BackSide}),
				new THREE.MeshBasicMaterial({map: imgl.load(path+'ny.png'), side: THREE.BackSide}),
				new THREE.MeshBasicMaterial({map: imgl.load(path+'pz.png'), side: THREE.BackSide}),
				new THREE.MeshBasicMaterial({map: imgl.load(path+'nz.png'), side: THREE.BackSide}),
			]

			var spheretexture = imgl.load(path+'lounge.png');

			loader.setPath( 'textures/irradiancemap/' );
			var irradianceMap = loader.load( [
					'posx.png', 'negx.png',
					'posy.png', 'negy.png',
					'posz.png', 'negz.png'
			] );			

			var textureParameters = {
				normalScale: 1.0,
				roughness: 0.2,
				roughnessmetal: 0.2,
				roughnessglass: 0.4,
				repeatS: 1.0,
				repeatT: 1.0,
				textureMap: ''
			}

			var uniforms = {
				diffuseMap: { type: "t", value: diffuseMap },
				roughnessMap: { type: "t", value: roughnessMap },
				specularMap: { type: "t", value: specularMap },
				
				normalMap:	{ type: "t", value: normalMap },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};
			
			var uniformsMetal = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMap },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			var uniformsGlass = {
				mBias: { type: 'f', value: 0.1 },
				mPower: { type: 'f', value: 2.0 },
				mScale: { type: 'f', value: 1.0 },

				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMap },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			var uniformsChair = {
				mBias: { type: 'f', value: 0.1 },
				mPower: { type: 'f', value: 2.0 },
				mScale: { type: 'f', value: 1.0 },

				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				diffuseMap: { type: "t", value: diffuseMapChair },
				roughnessMap: { type: "t", value: roughnessMapChair },
				specularMap: { type: "t", value: specularMapChair },
				
				normalMap:	{ type: "t", value: normalMapChair },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			var uniformsChairMetal = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMapChair },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			var uniformsChairGlass = {
				mBias: { type: 'f', value: 0.1 },
				mPower: { type: 'f', value: 2.0 },
				mScale: { type: 'f', value: 1.0 },

				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMapChair },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			var uniformsLegs = {
				mBias: { type: 'f', value: 0.1 },
				mPower: { type: 'f', value: 2.0 },
				mScale: { type: 'f', value: 1.0 },

				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				diffuseMap: { type: "t", value: diffuseMapLegs },
				roughnessMap: { type: "t", value: roughnessMapLegs },
				specularMap: { type: "t", value: specularMapLegs },
				
				normalMap:	{ type: "t", value: normalMapLegs },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			var uniformsLegsMetal = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMapLegs },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			var uniformsLegsGlass = {
				mBias: { type: 'f', value: 0.1 },
				mPower: { type: 'f', value: 2.0 },
				mScale: { type: 'f', value: 1.0 },

				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				cdiff:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMapLegs },
				normalScale: { type: "v2", value: new THREE.Vector2(1,1) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight:	{ type: "v3", value: new THREE.Vector3() },
			};

			materialExtensions = {
				derivatives: true,
				shaderTextureLOD: true
			};

			shaderMaterial = new THREE.ShaderMaterial({
				extensions: materialExtensions,
				uniforms: uniforms,
				vertexShader: document.getElementById('vs').textContent,
				fragmentShader: document.getElementById('fs_wood').textContent
			});

			shaderMaterialChair = new THREE.ShaderMaterial({
				extensions: materialExtensions,
				uniforms: uniformsChair,
				vertexShader: document.getElementById('vs').textContent,
				fragmentShader: document.getElementById('fs_wood').textContent
			});

			shaderMaterialLegs = new THREE.ShaderMaterial({
				extensions: materialExtensions,
				uniforms: uniformsLegs,
				vertexShader: document.getElementById('vs').textContent,
				fragmentShader: document.getElementById('fs_wood').textContent
			});

			function Start() {
				
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				scene = new THREE.Scene();

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';

				renderer.setClearColor( 0xf0f0f0 );

				camera.position.set( 6, 10, 35 );
				scene.add( camera );

				document.body.appendChild( renderer.domElement );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );

				cubescene = new THREE.Mesh(
					new THREE.SphereBufferGeometry(40, 64, 64),
					new THREE.MeshBasicMaterial({map:spheretexture, side: THREE.BackSide})
				);
				cubescene.position.set(0, 25, 0);
				cubescene.doubleSided = true;
				cubescene.receiveShadow = true;
				scene.add(cubescene);

				lightMesh = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16),
					new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true}));
				lightMesh.position.set( 7.0, 7.0, 7.0 );
				uniforms.pointLightPosition.value = new THREE.Vector3(
					lightMesh.position.x,
					lightMesh.position.y,
					lightMesh.position.z
				);
				lightMesh.castShadow = true;
				scene.add(lightMesh);

				lightMesh2 = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16),
				new THREE.MeshBasicMaterial ({color: 0xff0000, wireframe:true}));
				lightMesh2.position.set( -7.0, 7.0, 7.0 );
				uniforms.pointLightPosition2.value = new THREE.Vector3(
					lightMesh2.position.x,
					lightMesh2.position.y,
					lightMesh2.position.z
				);
				//scene.add(lightMesh2);
				
				lightMesh3 = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16),
				new THREE.MeshBasicMaterial ({color: 0x0000ff, wireframe:true}));
				lightMesh3.position.set( 7.0, -3.0, -7.0 );
				uniforms.pointLightPosition3.value = new THREE.Vector3(
					lightMesh3.position.x,
					lightMesh3.position.y,
					lightMesh3.position.z
				);
				//scene.add(lightMesh3);

				//scene.background = textureCube;
				document.addEventListener( 'mousedown', onDocumentMouseDown );
				controls.update();

			}

			function onDocumentMouseDown( event ) {    
				event.preventDefault();
				var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
					-( event.clientY / window.innerHeight ) * 2 + 1,  
					0.5 );     
				var raycaster =  new THREE.Raycaster();                                        
				raycaster.setFromCamera( mouse3D, camera );
				var intersects = raycaster.intersectObjects( objects);
				
				if ( intersects.length > 0 ) {
					console.log(intersects[0].object.name);
					selection = intersects[0].object.name;

					scene.getObjectByName(selection).material = new THREE.MeshBasicMaterial({
						color: 0xff0000, 
						opacity: 0.3, 
						transparent: true});
				}
			}

			function Update(time) {
				time *= 0.001;
				requestAnimationFrame(Update);

				/*
				lightMesh.position.x = Math.cos(time*0.5)*7;
				lightMesh.position.x = Math.cos(time*0.5)*7;
				lightMesh.position.x = Math.cos(time*0.5)*7;
				*/

				stats.update();
				Render();
			}

			function Render() {

				if(loadedModel) {

					if(mesh.name=='bigchair') {
						mesh.position.x = 6;
						mesh.position.y = -5;
						mesh.position.z = 3;

						mesh.rotation.z = 60 * 3.14159 / 180;
						mesh.rotation.x = - 90 * 3.14159 / 180;
						
					} else /*if(mesh.name=='dresser')*/ {
						mesh.position.x = -7;
						mesh.position.y = -5;
						mesh.position.z = -2;

						mesh.rotation.y = 45 * 3.14159 / 180;
					}
					
					scene.add(mesh);

					
				}

				updateUniforms();
				updateUniformsChair();
				updateUniformsLegs();
				renderer.render(scene, camera);
			}

			function updateUniforms() {
				uniformsMetal.cdiff.value = new THREE.Vector3(
					cdiffmetal.red,
					cdiffmetal.green,
					cdiffmetal.blue
				)
				uniformsGlass.cdiff.value = new THREE.Vector3(
					cdiffglass.red,
					cdiffglass.green,
					cdiffglass.blue
				);

				uniformsMetal.cspec.value = new THREE.Vector3(
					cspecmetal.red,
					cspecmetal.green,
					cspecmetal.blue
				);
				uniformsGlass.cspec.value = new THREE.Vector3(
					cspecglass.red,
					cspecglass.green,
					cspecglass.blue
				);

				uniforms.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);
				uniformsMetal.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);
				uniformsGlass.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);

				uniforms.textureRepeat.value = new THREE.Vector2( 
					textureParameters.repeatS, 
					textureParameters.repeatT
				);

				uniforms.specularMap.value = specularMap;
				uniforms.diffuseMap.value = diffuseMap;
				uniforms.roughnessMap.value = roughnessMap;

				uniforms.normalMap.value = normalMap;
				uniformsMetal.normalMap.value = normalMap;
				uniformsGlass.normalMap.value = normalMap;

				uniforms.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);
				uniformsMetal.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);
				uniformsGlass.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);

				uniformsMetal.roughness.value = textureParameters.roughnessmetal;
				uniformsGlass.roughness.value = textureParameters.roughnessglass;
			}

			function updateUniformsChair() {
				uniformsChairMetal.cdiff.value = new THREE.Vector3(
					cdiffmetal.red,
					cdiffmetal.green,
					cdiffmetal.blue
				);
				uniformsChairMetal.cspec.value = new THREE.Vector3(
					cspecmetal.red,
					cspecmetal.green,
					cspecmetal.blue
				);

				uniformsChairGlass.cdiff.value = new THREE.Vector3(
					cdiffglass.red,
					cdiffglass.green,
					cdiffglass.blue
				);
				uniformsChairGlass.cspec.value = new THREE.Vector3(
					cspecglass.red,
					cspecglass.green,
					cspecglass.blue
				);

				uniformsChair.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);
				uniformsChairMetal.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);
				uniformsChairMetal.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);

				uniformsChair.textureRepeat.value = new THREE.Vector2( 
					textureParameters.repeatS, 
					textureParameters.repeatT
				);

				uniformsChair.specularMap.value = specularMapChair;
				uniformsChair.diffuseMap.value = diffuseMapChair;
				uniformsChair.roughnessMap.value = roughnessMapChair;

				uniformsChair.normalMap.value = normalMapChair;
				uniformsChair.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);
				uniformsChairMetal.normalMap.value = normalMapChair;
				uniformsChairMetal.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);
				uniformsChairGlass.normalMap.value = normalMapChair;
				uniformsChairGlass.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);

				uniformsChairMetal.roughness.value = textureParameters.roughnessmetal;
				uniformsChairGlass.roughness.value = textureParameters.roughnessglass;
			}

			function updateUniformsLegs() {
				uniformsLegsMetal.cdiff.value = new THREE.Vector3(
					cdiffmetal.red,
					cdiffmetal.green,
					cdiffmetal.blue
				);
				uniformsLegsMetal.cspec.value = new THREE.Vector3(
					cspecmetal.red,
					cspecmetal.green,
					cspecmetal.blue
				);

				uniformsLegsGlass.cdiff.value = new THREE.Vector3(
					cdiffglass.red,
					cdiffglass.green,
					cdiffglass.blue
				);
				uniformsLegsGlass.cspec.value = new THREE.Vector3(
					cspecglass.red,
					cspecglass.green,
					cspecglass.blue
				);

				uniformsLegs.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);
				uniformsLegsMetal.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);
				uniformsLegsMetal.clight.value = new THREE.Vector3(
					lightParameters.red * lightParameters.intensity,
					lightParameters.green * lightParameters.intensity,
					lightParameters.blue * lightParameters.intensity
				);

				uniformsLegs.textureRepeat.value = new THREE.Vector2( 
					textureParameters.repeatS, 
					textureParameters.repeatT
				);

				uniformsLegs.specularMap.value = specularMapLegs;
				uniformsLegs.diffuseMap.value = diffuseMapLegs;
				uniformsLegs.roughnessMap.value = roughnessMapLegs;

				uniformsLegs.normalMap.value = normalMapLegs;
				uniformsLegs.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);
				uniformsLegsMetal.normalMap.value = normalMapLegs;
				uniformsLegsMetal.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);
				uniformsLegsGlass.normalMap.value = normalMapLegs;
				uniformsLegsGlass.normalScale.value = new THREE.Vector2( 
					textureParameters.normalScale, 
					textureParameters.normalScale 
				);

				uniformsLegsMetal.roughness.value = textureParameters.roughnessmetal;
				uniformsLegsGlass.roughness.value = textureParameters.roughnessglass;
			}

			function clearGui() {
				if ( gui ) gui.destroy();
				gui = new dat.GUI();
				gui.open();
			}

			var woodShader = function() {
				this.material = function() {
					/*textureParameters.roughness = 0.5;
					cdiff.red = 0.5;
					cdiff.green = 0.5;
					cdiff.blue = 0.5;
					cspec.red = 0.8;
					cspec.green = 0.8;
					cspec.blue = 0.8;*/
					
					//shaderMaterial.fragmentShader = document.getElementById('fs_wood').textContent;

					var selected = scene.getObjectByName(selection);

					if (selected.parent.name == "bigchair") {
						selected.material = new THREE.ShaderMaterial({
							extensions: materialExtensions,
							uniforms: uniformsChair,
							vertexShader: document.getElementById('vs').textContent,
							fragmentShader: document.getElementById('fs_wood').textContent
						});

						if(selection == 'Chair_foot') {
							selected.material = new THREE.ShaderMaterial({
								extensions: materialExtensions,
								uniforms: uniformsLegs,
								vertexShader: document.getElementById('vs').textContent,
								fragmentShader: document.getElementById('fs_wood').textContent
							});
						}

					} else /*if(selected.parent.name=="dresser")*/ {
						selected.material = new THREE.ShaderMaterial({
							extensions: materialExtensions,
							uniforms: uniforms,
							vertexShader: document.getElementById('vs').textContent,
							fragmentShader: document.getElementById('fs_wood').textContent
						});
					}

					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();

					/*for(i=0; i<mesh.children.length; i++) {
						scene.remove(mesh.children[i]);
						mesh.children[i].geometry.dispose();
						mesh.children[i].material.dispose();
					}*/

				}
				
				this.brown = function() {
					diffuseMapChair = textureLoader('textures/bigchair/Lchair.jpg');
				}
				this.red = function() {
					diffuseMapChair = textureLoader('textures/bigchair/Lredchair.jpg');
				}
				this.black = function() {
					diffuseMapChair = textureLoader('textures/bigchair/Lblackchair.jpg');
				}
				this.blue = function() {
					diffuseMapChair = textureLoader('textures/bigchair/Lbluechair.jpg');
				}
				this.white = function() {
					diffuseMapChair = textureLoader('textures/bigchair/Lwhitechair.jpg');
				}

				this.wood1 = function() {
					diffuseMap = textureLoader('textures/dresser/wood1.jpg');
				}
				this.wood2 = function() {
					diffuseMap = textureLoader('textures/dresser/wood2.png');
				}
				this.wood3 = function() {
					diffuseMap = textureLoader('textures/dresser/wood3.png');
				}
				this.wood4 = function() {
					diffuseMap = textureLoader('textures/dresser/diffuse.png');
				}
			}
			var woodMaterial = new woodShader();

			var goldShader = function() {
				this.gold = function() {
					textureParameters.roughnessmetal = 0.2;
					cdiffmetal.red = 0.83;
					cdiffmetal.green = 0.69;
					cdiffmetal.blue = 0.22;
					cspecmetal.red = 1.0;
					cspecmetal.green = 0.78;
					cspecmetal.blue = 0.34;

					//shaderMaterial.fragmentShader = document.getElementById('fs_gold').textContent;

					var selected = scene.getObjectByName(selection);
					if(selection == 'Chair_foot') {
							selected.material = new THREE.ShaderMaterial({
								extensions: materialExtensions,
								uniforms: uniformsLegsMetal,
								vertexShader: document.getElementById('vs').textContent,
								fragmentShader: document.getElementById('fs_gold').textContent
							});
					} else if (selection == "Chair_back"
						|| selection == "Chair_button"
						|| selection == "Chair_metal") {

						selected.material = new THREE.ShaderMaterial({
							extensions: materialExtensions,
							uniforms: uniformsChairMetal,
							vertexShader: document.getElementById('vs').textContent,
							fragmentShader: document.getElementById('fs_gold').textContent
						});
					} else /*if(selected.parent.name=="dresser")*/ {
						selected.material = new THREE.ShaderMaterial({
							extensions: materialExtensions,
							uniforms: uniformsMetal,
							vertexShader: document.getElementById('vs').textContent,
							fragmentShader: document.getElementById('fs_gold').textContent
						});
					}

					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();

					/*
					for(i=0; i<mesh.children.length; i++) {
						scene.remove(mesh.children[i]);
						mesh.children[i].geometry.dispose();
						mesh.children[i].material.dispose();
					}*/
				}
				this.copper = function () {
					textureParameters.roughnessmetal = 0.2;

					cdiffmetal.red = 0.72;
					cdiffmetal.green = 0.45;
					cdiffmetal.blue = 0.2;

					cspecmetal.red = 0.955;
					cspecmetal.green = 0.638;
					cspecmetal.blue = 0.538;
				}
			}
			var goldMaterial = new goldShader();

			var glassShader = function() {
				this.glass = function() {
					/*textureParameters.roughnessglass = 0.3;
					cdiffglass.red = 1.0;
					cdiffglass.blue = 1.0;
					cdiffglass.green = 1.0;
					cspecglass.red = 0.8;
					cspecglass.green = 0.8;
					cspecglass.blue = 0.8;*/
					//shaderMaterial.fragmentShader = document.getElementById('fs_refraction').textContent;
					
					var selected = scene.getObjectByName(selection);
					if(selection == 'Chair_foot') {
							selected.material = new THREE.ShaderMaterial({
								extensions: materialExtensions,
								uniforms: uniformsLegsGlass,
								vertexShader: document.getElementById('vs').textContent,
								fragmentShader: document.getElementById('fs_refraction').textContent
							});
					} else if (selection == "Chair_back"
						|| selection == "Chair_button"
						|| selection == "Chair_metal") {

						selected.material = new THREE.ShaderMaterial({
							extensions: materialExtensions,
							uniforms: uniformsChairGlass,
							vertexShader: document.getElementById('vs').textContent,
							fragmentShader: document.getElementById('fs_refraction').textContent
						});
					} else /*if(selected.parent.name=="dresser")*/ {
						selected.material = new THREE.ShaderMaterial({
							extensions: materialExtensions,
							uniforms: uniformsGlass,
							vertexShader: document.getElementById('vs').textContent,
							fragmentShader: document.getElementById('fs_refraction').textContent
						});
					}

					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();

					/*for(i=0; i<mesh.children.length; i++) {
						scene.remove(mesh.children[i]);
						mesh.children[i].geometry.dispose();
						mesh.children[i].material.dispose();
					}*/
					
				}
			}
			var glassMaterial = new glassShader();

			function buildGui() {
				clearGui();

				gui.add(textureParameters,'normalScale').min(-3).max(3)
				//gui.add(textureParameters,'roughnessmetal').min(0).max(1);

				var gl = gui.addFolder('glass params');
				gl.add(textureParameters,'roughnessglass').min(0).max(1);

				var mt = gui.addFolder('metal params');
				mt.add(cdiffmetal,'red').min(0).max(1);
				mt.add(cdiffmetal,'green').min(0).max(1);
				mt.add(cdiffmetal,'blue').min(0).max(1);

				gui.add(woodMaterial, 'material');
				var leather = gui.addFolder('leather color');
				leather.add(woodMaterial, 'brown');
				leather.add(woodMaterial, 'red');
				leather.add(woodMaterial, 'blue');
				leather.add(woodMaterial, 'black');
				leather.add(woodMaterial, 'white');

				var wood = gui.addFolder('wood type');
				wood.add(woodMaterial, 'wood1');
				wood.add(woodMaterial, 'wood2');
				wood.add(woodMaterial, 'wood3');
				wood.add(woodMaterial, 'wood4');

				gui.add(goldMaterial, 'gold');
				gui.add(goldMaterial,  'copper');
				gui.add(glassMaterial, 'glass');
			}

			modelLoader("dresser");
			modelLoader("bigchair");
			Start();
			buildGui();
			Update();
			Render();

			function modelLoader( name ) {
				var loader = new THREE.OBJLoader();

				var load = loader.load( "models/"+name+".obj", 
					function ( obj ) {
						
						shaderMaterial.needsUpdate = true;

						mesh = obj;
						mesh.scale.multiplyScalar( 0.07 );
						if(name == 'chessKing')
							mesh.scale.multiplyScalar( 30 );

						mesh.name = name;

						for (i=0; i<mesh.children.length; i++) {
							if (name=='bigchair') {
								mesh.children[i].material = shaderMaterialChair;

								if(mesh.children[i].name == 'Chair_foot')
									mesh.children[i].material = shaderMaterialLegs;

							} else {
								mesh.children[i].material = shaderMaterial;
							}

							mesh.children[i].castShadow = true;
							mesh.children[i].receiveShadow = true;
							objects.push(mesh.children[i]);
						}

						loadedModel = true;
				} );
			}

			function textureLoader(file) {
				var texture = new THREE.TextureLoader().load( file , function ( texture ) {

				texture.minFilter = THREE.LinearMipMapLinearFilter;
				texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.offset.set( 0, 0 );
					texture.needsUpdate = true;
					Render();
				} )
				return texture;
			}


		</script>

		

	</body> 
</html>