<html>
	<head>
		<title>Product Visualizer</title>
		
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<div>
			<div class="topnav">
				<a href="#home">Home</a>
				<a href="#products">Products</a>
				<a class='active' href="#customize">Customize</a>
				<a href="#about">About</a>
			</div>
			<div >
				<span class='banner'>Customize</span><span class='subtitle'> your living room</span>
			</div>
			<div class='row'>
				<div class='col-sm-8' id="container" ></div>
			
			
				<div class='menu col-sm-3'>
					<div >
						<div ><label class='label' >Chair rotation:</label><label id='chairR'></label></div>
						<div ><input type='range' min='0' max='360' value='0' class="slider" id='rotchair' oninput='rotate(event)' /></div>
					</div>
					<br/>
					<div >
						<div ><label class='label'>Dresser rotation:</label><label id='dresserR'></label></div>
						<div ><input type='range' min='0' max='360' value='0' class="slider" id='rotdresser' oninput='rotate(event)'/></div>
					</div>

					<hr/>

					<div >
						<div style="text-align: left; font-family: Verdana; font-size: 15px;">
							<label>Choose an object</label>
							<form style='margin-left:10px;' id='form' onclick='unlockFunction()'>
								<input style='margin-left: 10px' type="radio" name="object" value="chair">Armchair</input><br/>
								<input style='margin-left: 10px' type="radio" name="object" value="dresser">Dresser</input>
							</form>
						</div>
						<select id='selector'>
							<option value='none'>Select an object</option>
						</select>
						<button class='dropbtn' 
							id='selectbutton'
							disabled
							onclick='selectFunction(document.getElementById("selector").value);'>
							Select
						</button>
						<br/>
						<span style='color:red; opacity: 0.8; font-size: 13px;'>The selected component will be highlighted in red</span>
						<br/>
						<br/>
						<label>Customize the material</label>
						<select id='applier' disabled>
							<option value='none'>Select a component</option>
						</select>
						<button class='dropbtn' 
							id='applybutton'
							disabled
							onclick='applyFunction(document.getElementById("applier").value);'>
							Select
						</button>
					</div>
					
				</div>
			</div>
			
			<div class='row'>
				<div class='col-sm-9'></div>
				<div class='col-sm-3' style='text-align: center;'>
					<button class='dropbtn'>
						Confirm and order >>
					</button>
				</div>

			</div>
		</div>

		<script src="libs\three.min.js"></script>
		<script src="libs\stats.min.js"></script> 
		<script src="libs\OrbitControls.js"></script> 
		<!-- <script src="libs\Coordinates.js"></script> -->
		<script src='libs\OBJLoader.js'></script>
		<!-- <script src='libs\GLTFLoader.js'></script> -->
		<script src='libs\dat.gui.min.js'></script>
		<!-- <script src='libs\BufferGeometryUtils.js'></script> -->
		<script src='libs\SceneUtils.js'></script>

		<script type='text/x-glsl' id='vs'>
			attribute vec4 tangent;
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec3 vTangent;
			varying vec3 vBitangent;
			varying vec2 vUv;
			varying vec3 wNormal;
			
			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
				vNormal = normalize(normalMatrix * normal);
				vec3 objectTangent = vec3( tangent.xyz );
				vec3 transformedTangent = normalMatrix * objectTangent;
				vTangent = normalize( transformedTangent );
				vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
				vUv = uv;
				wNormal = (modelViewMatrix * vec4(vNormal, 0.0)).xyz;
				gl_Position = projectionMatrix * vPos;
			}
		</script>

		<script type='text/x-glsl' id='fs_texture'>
			precision highp float;
			precision highp int;

			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec3 vNormal;
			varying vec3 wNormal;
			varying vec2 vUv;

			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;

			uniform vec3 clight;
			uniform vec3 clight2;
			uniform vec3 clight3;
			uniform samplerCube envMap;

			vec3 cdiff;
			uniform sampler2D diffuseMap;
			
			uniform vec3 cspec;

			float roughness;
			uniform sampler2D roughnessMap;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			uniform samplerCube irradianceMap;

			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			#define saturate(a) clamp( a, 0.0, 1.0 )

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
				float k = roughness*roughness;
				return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;
			}

			void main() {

				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);

				//OBJ MODEL
				//TO MAKE NORMAL MAP WORK perturbNormal2Arb(...)
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition, n);
				vec3 r = inverseTransformDirection(vReflect, viewMatrix);

				vec3 h = normalize( v + l);
				vec3 h2 = normalize( v + l2);
				vec3 h3 = normalize( v + l3);

				float nDotl = max(dot( n, l ),0.000001);
				float nDotl2 = max(dot( n, l2 ),0.000001);
				float nDotl3 = max(dot( n, l3 ),0.000001);

				float lDoth = max(dot( l, h ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);

				float nDoth = max(dot( n, h ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);

				float vDoth = max(dot( v, h ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
				cdiff = pow( cdiff, vec3(2.2));
				roughness = texture2D(roughnessMap, vUv*textureRepeat).r;

				vec3 fresnel = FSchlick( lDoth );
				vec3 fresnel2 = FSchlick( lDoth2 );
				vec3 fresnel3 = FSchlick( lDoth3 );

				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);
				vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);
				vec3 BRDF3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);

				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent,8 );

	 			vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
				envLight = pow( envLight, vec3(2.2));

				vec3 outRadiance = ( (BRDF*nDotl*clight) + (nDotl2*BRDF2*clight2) + (nDotl3*BRDF3*clight3) ) *PI;

				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);

			}
		</script>

		<script type='text/x-glsl' id='fs_metal' >
			precision highp float; 
			precision highp int;

			varying vec3 vPosition;
			varying vec3 wPosition;

			varying vec3 vNormal;
			varying vec3 wNormal;
			varying vec2 vUv;

			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;
			
			uniform vec3 clight;
			uniform vec3 clight2;
			uniform vec3 clight3;

			uniform samplerCube envMap;

			uniform vec3 cspec;
			uniform float roughness;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			const float PI = 3.14159;

			#define saturate(a) clamp( a, 0.0, 1.0 )

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
				float k = roughness*roughness;
				return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);

				//OBJ MODEL
				//TO MAKE NORMAL MAP WORK perturbNormal2Arb(...)
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition, n);
				vec3 r = inverseTransformDirection(vReflect, viewMatrix);

				vec3 h = normalize( v + l);
				vec3 h2 = normalize( v + l2);
				vec3 h3 = normalize( v + l3);

				float nDotl = max(dot( n, l ),0.000001);
				float nDotl2 = max(dot( n, l2 ),0.000001);
				float nDotl3 = max(dot( n, l3 ),0.000001);

				float lDoth = max(dot( l, h ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);

				float nDoth = max(dot( n, h ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);

				float vDoth = max(dot( v, h ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				vec3 fresnel = FSchlick( lDoth );
				vec3 fresnel2 = FSchlick( lDoth2 );
				vec3 fresnel3 = FSchlick( lDoth3 );

				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent,8 );

	 			vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
	 			// texture in sRGB, linearize
				envLight = pow( envLight, vec3(2.2));

				vec3 sBRDF = BRDF_Specular_GGX_Environment(n, v, cspec, roughness);

				vec3 BRDF = fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);
				vec3 BRDF2 = fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);
				vec3 BRDF3 = fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);

				vec3 outRadiance = envLight * sBRDF + ( (BRDF*nDotl*clight) + (nDotl2*BRDF2*clight2) + (nDotl3*BRDF3*clight3) ) * PI;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
				//gl_FragColor = vec4(r,1.0);
			}
		</script>

		<script type='text/x-glsl' id='fs_plastic' >
			precision highp float;
			precision highp int;

			varying vec3 vPosition;
			varying vec3 wPosition;
			varying vec3 vNormal;
			varying vec3 wNormal;
			varying vec2 vUv;

			uniform vec3 pointLightPosition;
			uniform vec3 pointLightPosition2;
			uniform vec3 pointLightPosition3;

			uniform vec3 clight;
			uniform vec3 clight2;
			uniform vec3 clight3;
			uniform samplerCube envMap;

			uniform vec3 cdiff;
			uniform vec3 cspec;
			uniform float roughness;

			uniform sampler2D normalMap;
			uniform vec2 normalScale;

			uniform samplerCube irradianceMap;

			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			#define saturate(a) clamp( a, 0.0, 1.0 )

			float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
				float k = roughness*roughness;
				return G1(nDotl,k)*G1(nDotv,k);
			}

			vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {
				vec3 q0 = dFdx( eye_pos.xyz );
				vec3 q1 = dFdy( eye_pos.xyz );
				vec2 st0 = dFdx( vUv.st );
				vec2 st1 = dFdy( vUv.st );

				vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
				vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
				vec3 N =  surf_norm ;

				vec3 mapN = normalize(texture2D( normalMap, vUv ).xyz * 2.0 - 1.0);
				mapN.xy = normalScale * mapN.xy;
				mat3 tsn = mat3( S, T, N );
				return normalize( tsn * mapN );
			}

			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;
			}

			void main() {

				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				vec4 lPosition3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 l3 = normalize(lPosition3.xyz - vPosition.xyz);

				//OBJ MODEL
				//TO MAKE NORMAL MAP WORK perturbNormal2Arb(...)
				vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 v = normalize( -vPosition);
				vec3 vReflect = reflect(vPosition, n);
				vec3 r = inverseTransformDirection(vReflect, viewMatrix);

				vec3 h = normalize( v + l);
				vec3 h2 = normalize( v + l2);
				vec3 h3 = normalize( v + l3);

				float nDotl = max(dot( n, l ),0.000001);
				float nDotl2 = max(dot( n, l2 ),0.000001);
				float nDotl3 = max(dot( n, l3 ),0.000001);

				float lDoth = max(dot( l, h ),0.000001);
				float lDoth2 = max(dot( l2, h2 ),0.000001);
				float lDoth3 = max(dot( l3, h3 ),0.000001);

				float nDoth = max(dot( n, h ),0.000001);
				float nDoth2 = max(dot( n, h2 ),0.000001);
				float nDoth3 = max(dot( n, h3 ),0.000001);

				float vDoth = max(dot( v, h ),0.000001);
				float vDoth2 = max(dot( v, h2 ),0.000001);
				float vDoth3 = max(dot( v, h3 ),0.000001);

				float nDotv = max(dot( n, v ),0.000001);

				vec3 fresnel = FSchlick( lDoth );
				vec3 fresnel2 = FSchlick( lDoth2 );
				vec3 fresnel3 = FSchlick( lDoth3 );

				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/(4.0*nDotl*nDotv);
				vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv,nDotl2)*DGGX(nDoth2,roughness*roughness)/(4.0*nDotl2*nDotv);
				vec3 BRDF3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv,nDotl3)*DGGX(nDoth3,roughness*roughness)/(4.0*nDotl3*nDotv);

				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent,8 );

	 			vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
				envLight = pow( envLight, vec3(2.2));

				vec3 irradiance = textureCube( irradianceMap, wNormal).rgb;
				irradiance = pow( irradiance, vec3(2.2));

				vec3 sBRDF = BRDF_Specular_GGX_Environment(n, v, cspec, roughness);

				vec3 outRadiance = (BRDF*nDotl*clight + BRDF3*clight3*nDotl3 + sBRDF*irradiance*cdiff) * PI;

				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>

		<script>
			var scene, camera, renderer;
			var stats, controls, gui;

			//variabili luci e oggetti
			var lightMesh, lightMesh2, lightMesh3;
			var textureCube, cubescene, mesh, pivot, pivot;

			//contenitore canvas
			var container = document.getElementById('container');

			//selezione oggetti
			var selected = new THREE.Object3D();
			var selection = '';
			var loadedChair = false;
			var loadedDresser = false;
			var loading = true;
			var dresserWood = 'Wood00';
			var chairLeather = 'Fabric23'

			//parametri di illuminazione
			var lightParameters = {
				red: 1.0,
				green: 1.0,
				blue: 0.6,
				intensity: 0.8,
			};
			var lightParameters2 = {
				red: 1.0,
				green: 1.0,
				blue: 0.8,
				intensity: 0.2,
			};
			var lightParameters3 = {
				red: 1.0,
				green: 1.0,
				blue: 1.0,
				intensity: 0.7,
			};

			//parametri per materiali plastici
			var cdiffpl = {
				red: 1,
				green: 1,
				blue: 1
			}

			//parametri per materiali metallici
			var cspecgold = {
				red: 1.022,
				green: 0.782,
				blue: 0.344
			};
			var cspeccopper = {
				red: 0.955,
				green: 0.638,
				blue: 0.538
			};
			var cspecalum = {
				red: 0.913,
				green: 0.922,
				blue: 0.924
			}

			//texture iniziali per i diversi oggetti
			//cassettiera
			var normalMap = textureLoader('textures/dresser/normal.png');
			var diffuseMap = textureLoader('textures/wood/'+dresserWood+'_col.jpg');
			var roughnessMap = textureLoader('textures/wood/'+dresserWood+'_rgh.jpg');

			//seduta della poltrona
			var normalMapChair = textureLoader('textures/leather/'+chairLeather+'_nrm.jpg');
			var diffuseMapChair = textureLoader('textures/leather/'+chairLeather+'_col.jpg');
			var roughnessMapChair = textureLoader('textures/leather/'+chairLeather+'_rgh.jpg');

			//gambe della poltrona
			var normalMapLegs = textureLoader('textures/bigchair/Wnormal.png');
			var diffuseMapLegs = textureLoader('textures/wood/'+dresserWood+'_col.jpg');
			var roughnessMapLegs = textureLoader('textures/bigchair/Wrough.png');

			var loader = new THREE.CubeTextureLoader();
			loader.setPath( 'textures/vetrata/' );
			//environment cubemap per riflessi
			var textureCube = loader.load( [
				'pz.png', 'nz.png',
				'py.png', 'ny.png',
				'px.png', 'nx.png'
			] );
			textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			//cubemap per stanza
			var imgl = new THREE.TextureLoader();
			var path = 'textures/vetrata/'
			var textureEnvironment = [
				new THREE.MeshPhongMaterial({map: imgl.load(path+'px.png'), side: THREE.BackSide}),
				new THREE.MeshPhongMaterial({map: imgl.load(path+'nx.png'), side: THREE.BackSide}),
				new THREE.MeshPhongMaterial({map: imgl.load(path+'py.png'), side: THREE.BackSide}),
				new THREE.MeshPhongMaterial({map: imgl.load(path+'ny.png'), side: THREE.BackSide}),
				new THREE.MeshPhongMaterial({map: imgl.load(path+'pz.png'), side: THREE.BackSide}),
				new THREE.MeshPhongMaterial({map: imgl.load(path+'nz.png'), side: THREE.BackSide}),
			];

			//irradiance map per oggetti diffusivi
			loader.setPath( 'textures/irradiancemap/' );
			var irradianceMap = loader.load( [
					'pz.png', 'nz.png',
					'py.png', 'ny.png',
					'nx.png', 'px.png'
			] );

			//parametri globali per materiali
			var textureParameters = {
				normalScale: 1.1,
				normalScaleMetal: 0.005,
				roughness: 0.65,
				roughnessmetal: 0.3,
				repeatS: 1.0,
				repeatT: 1.0,
				textureMap: ''
			}

			materialExtensions = {
				derivatives: true,
				shaderTextureLOD: true
			};

			//rotazione degli oggetti nella scena
			var rotationParameters = {
				chairR: 0.0,
				dresserR: 0.0,
				baseRchair: 220.0,
				baseRdresser: 55.0
			}

			var cl = new THREE.Vector3(
				lightParameters.red * lightParameters.intensity,
				lightParameters.green * lightParameters.intensity,
				lightParameters.blue * lightParameters.intensity
			);
			var cl2 = new THREE.Vector3(
				lightParameters2.red * lightParameters2.intensity,
				lightParameters2.green * lightParameters2.intensity,
				lightParameters2.blue * lightParameters2.intensity
			);
			var cl3 = new THREE.Vector3(
				lightParameters3.red * lightParameters3.intensity,
				lightParameters3.green * lightParameters3.intensity,
				lightParameters3.blue * lightParameters3.intensity
			);

			//uniforms cassettiera texture
			var uniforms = {
				diffuseMap: { type: "t", value: diffuseMap },
				roughnessMap: { type: "t", value: roughnessMap },
				cspec: { type: "v3", value: new THREE.Vector3(0.04, 0.04, 0.04) },
				
				roughness: { type: "f", value: textureParameters.roughness },
				cdiff : { type: "v3", value: new THREE.Vector3( 0.5, 0.5, 0.5)},
				
				normalMap:	{ type: "t", value: normalMap },
				normalScale: {type: "v2", value: new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(textureParameters.repeatS, textureParameters.repeatT) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};
			
			//uniforms cassettiera metallico
			var uniformsMetal = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: textureParameters.roughnessmetal },
				
				normalMap:	{ type: "t", value: normalMap },
				normalScale: {type: "v2", value: new THREE.Vector2(0.2,0.2) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};
			
			//uniforms poltrona texture (seduta)
			var uniformsChair = {
				diffuseMap: { type: "t", value: diffuseMapChair },
				roughnessMap: { type: "t", value: roughnessMapChair },
				cspec: { type: "v3", value: new THREE.Vector3(0.04, 0.04, 0.04) },
				
				roughness: { type: "f", value: textureParameters.roughness },
				cdiff : { type: "v3", value: new THREE.Vector3( 0.5, 0.5, 0.5)},

				normalMap:	{ type: "t", value: normalMapChair },
				normalScale: {type: "v2", value: new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(textureParameters.repeatS, textureParameters.repeatT) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};	
			
			//uniforms poltrona metallico (bottoni)
			var uniformsChairMetal = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMapChair },
				normalScale: {type: "v2", value: new THREE.Vector2(0.2,0.2) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};
			
			//uniforms gambe poltrona texture
			var uniformsLegs = {
				diffuseMap: { type: "t", value: diffuseMapLegs },
				roughnessMap: { type: "t", value: roughnessMapLegs },
				cspec: { type: "v3", value: new THREE.Vector3(0.04, 0.04, 0.04) },
				
				roughness: { type: "f", value: textureParameters.roughness },
				cdiff : { type: "v3", value: new THREE.Vector3( 0.5, 0.5, 0.5)},

				normalMap:	{ type: "t", value: normalMapLegs },
				normalScale: {type: "v2", value: new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(textureParameters.repeatS, textureParameters.repeatT) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};
			
			//uniforms gambe poltrona metallico
			var uniformsLegsMetal = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: 0.5 },
				
				normalMap:	{ type: "t", value: normalMapLegs },
				normalScale: {type: "v2", value: new THREE.Vector2(0.2,0.2) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};

			//uniforms cassetti texture
			var uniformsDrawers = {
				diffuseMap: { type: "t", value: diffuseMap },
				roughnessMap: { type: "t", value: roughnessMap },
				cspec: { type: "v3", value: new THREE.Vector3(0.04, 0.04, 0.04) },
				
				roughness: { type: "f", value: textureParameters.roughness },
				cdiff : { type: "v3", value: new THREE.Vector3( 0.5, 0.5, 0.5)},

				normalMap:	{ type: "t", value: normalMap },
				normalScale: {type: "v2", value: new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale) },

				irradianceMap:	{ type: "t", value: irradianceMap},

				textureRepeat: { type: "v2", value: new THREE.Vector2(textureParameters.repeatS, textureParameters.repeatT) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};
			
			//uniforms cassetti metallico
			var uniformsDrawersMetal = {
				cspec:	{ type: "v3", value: new THREE.Vector3(0.8,0.8,0.8) },
				roughness: { type: "f", value: textureParameters.roughnessmetal },
				
				normalMap:	{ type: "t", value: normalMap },
				normalScale: {type: "v2", value: new THREE.Vector2(0.2,0.2) },

				envMap: { type: "t", value: textureCube },

				pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
				pointLightPosition2: { type: "v3", value: new THREE.Vector3() },
				pointLightPosition3: { type: "v3", value: new THREE.Vector3() },

				clight: { type: 'v3', value: cl},
				clight2: { type: 'v3', value: cl2},
				clight3: { type: 'v3', value: cl3}
			};

			function Start() {
				
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xf0f0f0 );

				camera = new THREE.PerspectiveCamera( 33, window.innerWidth/window.innerHeight, 1, 1000 );
				//controllo della camera rimosso poichè è possibile la rotazione tramite interfaccia
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				
				scene = new THREE.Scene();

				camera.position.set( 20, 15, 65 );
				scene.add( camera );
				
				controls.target.set(-10,-7,-20);
				controls.enablePan = false;
				controls.enableZoom = false;
				controls.enableRotate = false;

				container.appendChild( renderer.domElement );
				renderer.setPixelRatio( window.devicePixelRatio );

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				renderer.setSize(container.clientWidth, container.clientWidth / (window.innerWidth/window.innerHeight));

				renderer.toneMapping = THREE.CineonToneMapping;
				renderer.toneMappingWhitePoint = 1.0;
				renderer.toneMappingExposure = 0.6;
				renderer.outputEncoding = THREE.sRGBEncoding;

				cubescene = new THREE.Mesh(
					new THREE.BoxBufferGeometry(80, 80, 80),
					textureEnvironment
				);
				cubescene.position.set(0, 20, 0);
				cubescene.rotation.y = -150 * 3.13159 / 180;
				cubescene.doubleSided = true;
				cubescene.receiveShadow = true;
				cubescene.castShadow = false;
				scene.add(cubescene);

				//oggetto pivot per ruotare la cassettiera, poichè ègli assi del modello non sono centrati sulla geometria
				pivot = new THREE.Object3D(); 
				pivot.name = 'pivot';
				pivot.position.set(-22, -20, -10);
				scene.add(pivot);

				pivot2 = new THREE.Object3D();
				pivot2.name = 'pivot2';
				pivot2.position.set(18, -20, -11);
				scene.add(pivot2);

				//prima luce leggermente gialla da interno
				lightMesh = new THREE.PointLight(0xffffa0, lightParameters.intensity, 400);
				lightMesh.position.set( -23, 57, 20 );
				lightMesh.castShadow = true;
				lightMesh.shadow.radius = 6;
				lightMesh.shadow.mapSize.width = 1024; 
				lightMesh.shadow.mapSize.height = 1024;
				lightMesh.shadow.bias = 0.0001;
				
				scene.add(lightMesh);

				//seconda luce non casta ombra per non creare confusione dato che arriva dalla stessa direzione della prima
				lightMesh2 = new THREE.PointLight(0xffffa0, lightParameters2.intensity,  400);
				lightMesh2.position.set(17, -18, 10);
				var sp2 = new THREE.Mesh( 
					new THREE.SphereBufferGeometry( 2,8,8),
					new THREE.MeshBasicMaterial ({color: 0x00ff00, wireframe:true})
				);
				lightMesh2.add(sp2);
				
				scene.add(lightMesh2);

				//terza luce proveniente dall'esterno, bianca come luce solare
				lightMesh3 = new THREE.PointLight(0xffffff, lightParameters3.intensity, 400);
				lightMesh3.position.set( 40, 30, 0 );
				lightMesh3.castShadow = true;
				lightMesh3.shadow.radius = 6;
				lightMesh3.shadow.mapSize.width = 1024; 
				lightMesh3.shadow.mapSize.height = 1024;
				lightMesh3.shadow.bias = 0.0001;

				scene.add(lightMesh3);
				
				//aggiornamento parametri posizione delle luci
				updateUniformsLights();

				controls.update();
			}

			function Update(time) {
				time *= 0.001;
				requestAnimationFrame(Update);
				//stats.update();
				Render();
			}

			function Render() {

				if(loading) {
					mesh.name == 'dresser' ? pivot.add(mesh) : pivot2.add(mesh);

					for(i=0; i<scene.children.length; i++) {
						
						if(scene.children[i].name == 'pivot2'){
							scene.children[i].children[0].position.set(4,3,-2);
						
						} else if(scene.children[i].name == 'pivot') {
							scene.children[i].children[0].position.set(0, 0, -10);
						}
					}
					loading = !(loadedDresser&&loadedChair);
						
				} else if(!loading) {
					for(i=0; i<scene.children.length; i++) {
						if(scene.children[i].name == 'pivot2'){
							scene.children[i].rotation.y = (rotationParameters.chairR+rotationParameters.baseRchair) * 3.14159 /180;
							
						} else if(scene.children[i].name == 'pivot') {
							scene.children[i].rotation.y = (rotationParameters.dresserR+rotationParameters.baseRdresser) * 3.14159 /180;
						}
					}
				}

				document.getElementById('chairR').innerHTML = (rotationParameters.chairR).toString().substr(0,5);
				document.getElementById('dresserR').innerHTML = (rotationParameters.dresserR).toString().substr(0,5);

				renderer.render(scene, camera);
			}

			//per come sono gestiti i materiali, essendo molteplici e su diversi oggetti,
			//non serve eseguire ad ogni passata l'aggiornamento delle uniform, ma solo quando necessario

			function updateUniformsLights() {
				uniforms.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,lightMesh.position.y,lightMesh.position.z);
				uniformsMetal.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,lightMesh.position.y,lightMesh.position.z);
				uniformsChair.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,lightMesh.position.y,lightMesh.position.z);
				uniformsChairMetal.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,lightMesh.position.y,lightMesh.position.z);
				uniformsLegs.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,lightMesh.position.y,lightMesh.position.z);
				uniformsLegsMetal.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,lightMesh.position.y,lightMesh.position.z);

				uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,lightMesh2.position.y,lightMesh2.position.z);
				uniformsMetal.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,lightMesh2.position.y,lightMesh2.position.z);
				uniformsChair.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,lightMesh2.position.y,lightMesh2.position.z);
				uniformsChairMetal.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,lightMesh2.position.y,lightMesh2.position.z);
				uniformsLegs.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,lightMesh2.position.y,lightMesh2.position.z);
				uniformsLegsMetal.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,lightMesh2.position.y,lightMesh2.position.z);

				uniforms.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x,lightMesh3.position.y,lightMesh3.position.z);
				uniformsMetal.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x,lightMesh3.position.y,lightMesh3.position.z);
				uniformsChair.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x,lightMesh3.position.y,lightMesh3.position.z);
				uniformsChairMetal.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x,lightMesh3.position.y,lightMesh3.position.z);
				uniformsLegs.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x,lightMesh3.position.y,lightMesh3.position.z);
				uniformsLegsMetal.pointLightPosition3.value = new THREE.Vector3(lightMesh3.position.x,lightMesh3.position.y,lightMesh3.position.z);
			}

			var textureShader = function() {
				//applicazione shader per il materiale della poltrone
				this.leather = function(img) {
					selected = scene.getObjectByName(selection);
					chairLeather = img;

					uniformsChair.diffuseMap.value = textureLoader('textures/leather/'+img+'_col.jpg');
					uniformsChair.roughnessMap.value = textureLoader('textures/leather/'+img+'_rgh.jpg');
					uniformsChair.normalMap.value = textureLoader('textures/leather/'+img+'_nrm.jpg');

					selected.material = new THREE.ShaderMaterial({
						extensions: materialExtensions,
						uniforms: uniformsChair,
						vertexShader: document.getElementById('vs').textContent,
						fragmentShader: document.getElementById('fs_texture').textContent
					});
				};

				//applicazione shader per il materiale legno
				this.wood = function(uniforms, img) {
					selected = scene.getObjectByName(selection);

					uniforms.roughnessMap.value = textureLoader('textures/wood/'+img+'_rgh.jpg');
					uniforms.diffuseMap.value = textureLoader('textures/wood/'+img+'_col.jpg');
					uniforms.normalScale.value = new THREE.Vector2(textureParameters.normalScale, textureParameters.normalScale);

					selected.material = new THREE.ShaderMaterial({
						extensions: materialExtensions,
						uniforms: uniforms,
						vertexShader: document.getElementById('vs').textContent,
						fragmentShader: document.getElementById('fs_texture').textContent
					});
				};
			};
			var textureMaterial = new textureShader();

			//applicazione shader per il materiale metallico
			var metalShader = function() {
				this.helper = function(cspec) {
					if(selection=='a_low Low')
						this.metalF(uniformsDrawersMetal, cspec);
					else if(selection=='legs') {
						selection = 'Low e_low';
						this.metalF(uniformsMetal, cspec);
						selection = 'Low c_low';
						this.metalF(uniformsMetal, cspec);
						selection = 'legs';
					} else if(selection=='Chair_foot')
						this.metalF(uniformsLegsMetal, cspec);
					else if(selection=='buttons') {
						selection='Chair_metal';
						this.metalF(uniformsChairMetal, cspec);
						selection='Chair_button';
						this.metalF(uniformsChairMetal, cspec);
						selection='buttons';
					} else
						this.metalF(uniformsMetal, cspec);
				}

				this.metalF = function(uniforms, cspec) {
					selected = scene.getObjectByName(selection);
					uniforms.cspec.value = new THREE.Vector3(
						cspec.red,
						cspec.green,
						cspec.blue
					);
					selected.material = new THREE.ShaderMaterial({
						extensions: materialExtensions,
						uniforms: uniforms,
						vertexShader: document.getElementById('vs').textContent,
						fragmentShader: document.getElementById('fs_metal').textContent
					});
				}
			};
			var metalMaterial = new metalShader();

			//applicazione shader per il materiale plastico
			var plasticShader = function() {
				this.plastic = function(uniforms) {
					selected = scene.getObjectByName(selection);
					uniforms.normalScale.value = new THREE.Vector2(textureParameters.normalScaleMetal, textureParameters.normalScaleMetal);

					uniforms.cdiff.value = new THREE.Vector3(
						cdiffpl.red,
						cdiffpl.green,
						cdiffpl.blue
					);
					
					selected.material = new THREE.ShaderMaterial({
						extensions: materialExtensions,
						uniforms: uniforms,
						vertexShader: document.getElementById('vs').textContent,
						fragmentShader: document.getElementById('fs_plastic').textContent
					});
				}
			};
			var plasticMaterial = new plasticShader();

			modelLoader("dresser");
			modelLoader("bigchair31");
			Start();
			Update();
			Render();

			//loader per i modelli con gestione dei materiali allocati dinamicamente al caricamento,
			//poichè diversi per ogni componente
			function modelLoader( name ) {
				var loader = new THREE.OBJLoader();

				var load = loader.load( "models/"+name+".obj", 
					function ( obj ) {

						mesh = obj;
						if(name=='bigchair31')
							mesh.scale.multiplyScalar(0.017);
						else 
							mesh.scale.multiplyScalar( 0.2 );

						mesh.name = name;

						for (i=0; i<mesh.children.length; i++) {
							if (name=='bigchair31') {
								mesh.children[i].material = new THREE.ShaderMaterial({
									extensions: materialExtensions,
									uniforms: uniformsChair,
									vertexShader: document.getElementById('vs').textContent,
									fragmentShader: document.getElementById('fs_texture').textContent
								});

								if(mesh.children[i].name == 'Chair_foot') {
									uniformsLegs.normalScale.value = new THREE.Vector2(textureParameters.normalScaleMetal, textureParameters.normalScaleMetal);
									mesh.children[i].material = new THREE.ShaderMaterial({
										extensions: materialExtensions,
										uniforms: uniformsLegs,
										vertexShader: document.getElementById('vs').textContent,
										fragmentShader: document.getElementById('fs_plastic').textContent
									});
								}

								uniformsChairMetal.cspec.value = new THREE.Vector3(cspecgold.red,cspecgold.green,cspecgold.blue);
								if(mesh.children[i].name == 'Chair_metal') {
									mesh.children[i].material = new THREE.ShaderMaterial({
										extensions: materialExtensions,
										uniforms: uniformsChairMetal,
										vertexShader: document.getElementById('vs').textContent,
										fragmentShader: document.getElementById('fs_metal').textContent
									});
								}
								if(mesh.children[i].name == 'Chair_button') {
									mesh.children[i].material = new THREE.ShaderMaterial({
										extensions: materialExtensions,
										uniforms: uniformsChairMetal,
										vertexShader: document.getElementById('vs').textContent,
										fragmentShader: document.getElementById('fs_metal').textContent
									});
								}

							} else if (name=='dresser') {
								mesh.children[i].material = new THREE.ShaderMaterial({
									extensions: materialExtensions,
									uniforms: uniforms,
									vertexShader: document.getElementById('vs').textContent,
									fragmentShader: document.getElementById('fs_texture').textContent
								});

								if(mesh.children[i].name == 'a_low Low') {
									uniformsDrawers.normalScale.value = new THREE.Vector2(textureParameters.normalScaleMetal, textureParameters.normalScaleMetal);
									mesh.children[i].material = new THREE.ShaderMaterial({
										extensions: materialExtensions,
										uniforms: uniformsDrawers,
										vertexShader: document.getElementById('vs').textContent,
										fragmentShader: document.getElementById('fs_plastic').textContent
									});
								}

								if(mesh.children[i].name == 'Low d_low') {
									uniformsMetal.cspec.value = new THREE.Vector3(cspecgold.red,cspecgold.green,cspecgold.blue);

									mesh.children[i].material = new THREE.ShaderMaterial({
										extensions: materialExtensions,
										uniforms: uniformsMetal,
										vertexShader: document.getElementById('vs').textContent,
										fragmentShader: document.getElementById('fs_metal').textContent
									});
									
								}
							}

							mesh.children[i].castShadow = true;
							mesh.children[i].receiveShadow = true;

							//objects.push(mesh.children[i]);
						}

						if(name=='bigchair31') {
							loadedChair = true;
						} else {
							loadedDresser = true;
						}

				} );
			}

			function textureLoader(file) {
				var texture = new THREE.TextureLoader().load( file , function ( texture ) {

				texture.minFilter = THREE.LinearMipMapLinearFilter;
				texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.offset.set( 0, 0 );
					texture.needsUpdate = true;
					Render();
				} )
				return texture;
			}

			//a seconda dell'oggetto selezionato, carica i suoi componenti per selezione più precisa tramite dropdown
			function unlockFunction() {
				if(document.getElementsByName('object')[0].checked) {
					document.getElementById('selector').innerHTML = 
						'<option value="Chair_back">Chair back</option>' +
						'<option value="buttons">Chair buttons</option>' +
						'<option value="Chair_foot">Chair legs</option>';
					document.getElementById('selectbutton').disabled = false;
					document.getElementById('selector').disabled = false;
				} else if(document.getElementsByName('object')[1].checked) {
					document.getElementById('selector').innerHTML = 
						'<option value="a_low Low">Dresser drawers</option>' +
						'<option value="Low d_low">Dresser knobs</option>' +
						'<option value="legs">Dresser legs</option>' +
						'<option value="Low b_low">Dresser structure</option>';
					document.getElementById('selectbutton').disabled = false;
					document.getElementById('selector').disabled = false;
				} else {
					document.getElementById('selector').innerHTML = '<option value="none">Select an object</option>';
				}
			}

			//una volta scelto un componente specifico, vengono caricate le possibili opzioni di materiale applicabile in dropdown
			function selectFunction(name) {
				selection = name;
				//struttura cassettiera
				if(name=='Low b_low') {
					scene.getObjectByName(selection).material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});

					document.getElementById('applier').innerHTML =
						'<option value="Wood26">Hazelnut wood</option>' +
						'<option value="Wood00">Ebony wood</option>' +
						'<option value="Wood31">Beech wood</option>' +
						'<option value="Wood35">Olive wood</option>' +
						'<option value="plastic">Colored plastic</option>';
				//cassetti cassettiera
				} else if (name=='a_low Low') {
					scene.getObjectByName(selection).material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});

					document.getElementById('applier').innerHTML =
						'<option value="Wood26">Hazelnut wood</option>' +
						'<option value="Wood00">Ebony wood</option>' +
						'<option value="Wood31">Beech wood</option>' +
						'<option value="Wood35">Olive wood</option>' +
						'<option value="plastic">Colored plastic</option>' +
						'<option value="gold">Metallic gold</option>' +
						'<option value="copper">Metallic copper</option>' +
						'<option value="alum">Metallic aluminium</option>' ;
				//pomelli cassettiera
				} else if(name=='Low d_low') {
					scene.getObjectByName(selection).material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});

					document.getElementById('applier').innerHTML =
						'<option value="woood">Wood</option>' +
						'<option value="plastic">Colored plastic</option>' +
						'<option value="gold">Metallic gold</option>' +
						'<option value="copper">Metallic copper</option>' +
						'<option value="alum">Metallic aluminium</option>' ;
				//gambe cassettiera
				} else if(name=='legs') {
					scene.getObjectByName("Low c_low").material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});
					scene.getObjectByName("Low e_low").material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});

					document.getElementById('applier').innerHTML =
						'<option value="woood">Wood</option>' + 
						'<option value="plastic">Colored plastic</option>' +
						'<option value="gold">Metallic gold</option>' +
						'<option value="copper">Metallic copper</option>' +
						'<option value="alum">Metallic aluminium</option>' ;
				//seduta poltrona
				} else if(name=='Chair_back') {
					scene.getObjectByName(selection).material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});

					document.getElementById('applier').innerHTML = 
						'<option value="Leather01">Brown leather</option>' +
						'<option value="Leather05">Red leather</option>' +
						'<option value="Fabric23">Blue cloth</option>' +
						'<option value="Fabric27">Green fabric</option>';
				//bottoni poltrona
				} else if(name=='buttons') {
					scene.getObjectByName("Chair_metal").material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});
					scene.getObjectByName("Chair_button").material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});

					document.getElementById('applier').innerHTML =
						'<option value="chair">Chair fabric</option>' +
						'<option value="plastic">Colored plastic</option>' +
						'<option value="gold">Metallic gold</option>' +
						'<option value="copper">Metallic copper</option>' +
						'<option value="alum">Metallic aluminium</option>' ;
				//gambe poltrona
				} else if(name=='Chair_foot') {
					scene.getObjectByName(name).material = new THREE.MeshBasicMaterial({
						color: 0xff0000,
						transparent: true,
						opacity: 0.3
					});
				
					document.getElementById('applier').innerHTML =
						'<option value="Wood26">Hazelnut wood</option>' +
						'<option value="Wood00">Ebony wood</option>' +
						'<option value="Wood31">Beech wood</option>' +
						'<option value="Wood35">Olive wood</option>' +
						'<option value="plastic">Colored plastic</option>' +
						'<option value="gold">Metallic gold</option>' +
						'<option value="copper">Metallic copper</option>' +
						'<option value="alum">Metallic aluminium</option>' ;
				};
				console.log(selection);

				document.getElementById('applybutton').disabled = false;
				document.getElementById('applier').disabled = false;
			}

			//applicazione del materiale a seconda della selezione,
			//shader diversi chiamati per diverse categorie di materiale
			function applyFunction(name) {
				switch(name) {
					case 'Leather01':
					case 'Leather05':
					case 'Fabric23': 
					case 'Fabric27': 
						textureMaterial.leather(name);
						break;
					case 'chair':
						if(selection=='buttons') {
							selection='Chair_metal';
							textureMaterial.leather(chairLeather);
							selection='Chair_button';
							textureMaterial.leather(chairLeather);
							selection='buttons';
						}
						break;
					case 'Wood00': 
					case 'Wood26':
					case 'Wood31': 
					case 'Wood35':
						selection=='Low b_low' ? dresserWood = name : null;
						if(selection=='a_low Low')
							textureMaterial.wood(uniformsDrawers, name);
						else if(selection=='Chair_foot') 
							textureMaterial.wood(uniformsLegs, name);
						else
							textureMaterial.wood(uniforms, name);
						break;
					case 'woood':
						if(selection=='legs') {
							selection = 'Low e_low';
							textureMaterial.wood(uniforms, dresserWood);
							selection = 'Low c_low';
							textureMaterial.wood(uniforms, dresserWood);
							selection = 'legs';
						} else 
							textureMaterial.wood(uniforms, dresserWood);
						break;
					case 'plastic':
						if(selection=='a_low Low')
							plasticMaterial.plastic(uniformsDrawers);
						else if(selection=='legs') {
							selection = 'Low e_low';
							plasticMaterial.plastic(uniforms);
							selection = 'Low c_low';
							plasticMaterial.plastic(uniforms);
							selection = 'legs';
						} else if(selection=='Chair_foot')
							plasticMaterial.plastic(uniformsLegs);
						else if(selection=='buttons') {
							selection='Chair_metal';
							plasticMaterial.plastic(uniformsChair);
							selection='Chair_button';
							plasticMaterial.plastic(uniformsChair);
							selection='buttons';
						} else
							plasticMaterial.plastic(uniforms);
						break;
					case 'gold':
						metalMaterial.helper(cspecgold);
						break;
					case 'copper':
						metalMaterial.helper(cspeccopper);
						break;
					case 'alum':
						metalMaterial.helper(cspecalum);
						break;
				}

				if(selection=='buttons') {
					selected = scene.getObjectByName('Chair_metal');
					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();
					selected = scene.getObjectByName('Chair_button');
					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();
				} else if(selection=='legs') {
					selected = scene.getObjectByName('Low c_low');
					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();
					selected = scene.getObjectByName('Low e_low');
					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();
				} else {
					selected = scene.getObjectByName(selection);
					scene.remove(selected);
					selected.geometry.dispose();
					selected.material.dispose();
				}
			}

			//applicazione rotazione agli oggetti
			function rotate(event) {
				if(event.target.id=='rotchair') rotationParameters.chairR = parseFloat(event.target.value);
				if(event.target.id=='rotdresser') rotationParameters.dresserR = parseFloat(event.target.value);
			}

		</script>
	</body> 
</html>
